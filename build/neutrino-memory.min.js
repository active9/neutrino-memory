(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.neutrinoMemory = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
(function (process){
(function(d){function m(b){p&&(q=b);}function h(b,a,c){var e=w(b);e.get=function(a,e){var d=parseInt(e,10)<<c;q||(f.isAddressable(d)||f.addBadAccessError(d),f.isDefined(d)||f.addUndefinedError(d));return b[e];};e.set=function(e,d,g){e=parseInt(d,10)<<c;q||(f.isAddressable(e)||f.addBadAccessError(e),f.setDefined(e,a,!0));b[d]=g;return!0;};return Proxy.create(e);}function t(){m(!0);var b=d.M=new ArrayBuffer(268435456);p?(f.reset(268435456),d.U1=h(new Uint8Array(b),1,0),d.I1=h(new Int8Array(b),1,0),d.U2=
h(new Uint16Array(b),2,1),d.I2=h(new Int16Array(b),2,1),d.U4=h(new Uint32Array(b),4,2),d.I4=h(new Int32Array(b),4,2),d.F4=h(new Float32Array(b),4,2),d.F8=h(new Float64Array(b),8,3)):(d.U1=new Uint8Array(b),d.I1=new Int8Array(b),d.U2=new Uint16Array(b),d.I2=new Int16Array(b),d.U4=new Uint32Array(b),d.I4=new Int32Array(b),d.F4=new Float32Array(b),d.F8=new Float64Array(b));d.U4[0]=4;d.U4[1]=67108864;r=2;n=0;m(!1);}function v(b){var a=l.U4,c=(b>>2)-2,e=0;p&&(m(!0),f.isAlloc(b)?(f.setAlloc(b,!1),f.setAddressable(b,
  a[c+1],!1),f.setDefined(b,a[c+1],!1)):f.addDoubleFreeError(b));for(e=n;!(c>e&&c<a[e]||e>=a[e]&&(c>e||c<a[e]));e=a[e]);c+2*a[c+1]===a[e]?(a[c+1]=(a[c+1]+a[a[e]+1]|0)>>>0,a[c]=a[a[e]]):a[c]=a[e];e+2*a[e+1]==c?(a[e+1]=(a[e+1]+a[c+1]|0)>>>0,a[e]=a[c]):a[e]=c;n=e;m(!1);}function w(b){return{getOwnPropertyDescriptor:function(a){a=Object.getOwnPropertyDescriptor(b,a);void 0!==a&&(a.configurable=!0);return a;},getPropertyDescriptor:function(a){a=Object.getPropertyDescriptor(b,a);void 0!==a&&(a.configurable=
!0);return a;},getOwnPropertyNames:function(){return Object.getOwnPropertyNames(b);},getPropertyNames:function(){return Object.getPropertyNames(b);},defineProperty:function(a,c){Object.defineProperty(b,a,c);},'delete':function(a){return delete b[a];},fix:function(){if(Object.isFrozen(b))return Object.getOwnPropertyNames(b).map(function(a){return Object.getOwnPropertyDescriptor(b,a);});},has:function(a){return a in b;},hasOwn:function(a){return Object.prototype.hasOwnProperty.call(b,a);},get:function(a,c){return b[c];},
set:function(a,c,e){b[c]=e;return!0;},enumerate:function(){var a=[],c;for(c in b)a.push(c);return a;},keys:function(){return Object.keys(b);}};}var l=d,p=!1,u;u='undefined'!==typeof process?1:'undefined'!==typeof snarf?2:3;var f;1===u?(print=console.log,f=require('./memcheck.js')):f=2===u?(load('memcheck.js'),memcheck):memcheck;var r=0,n=0,q=!1;t();d.reset=t;d.memcpy=function(b,a,c){for(var e=l.U1,d,f,g=0;g<c;g=g+1|0)e[d=b,b+=1,d]=e[f=a,a+=1,f];return b;};d.memcpy2=function(b,a,c){for(var e=l.U2,d,f,g=
0;g<c;g=g+1|0)e[d=b,b+=1,d]=e[f=a,a+=1,f];return b;};d.memcpy4=function(b,a,c){for(var e=l.U4,d,f,g=0;g<c;g=g+1|0)e[d=b,b+=1,d]=e[f=a,a+=1,f];return b;};d.memset=function(b,a,c){for(var e=l.U1,d=0;d<c;d=d+1|0)e[b]=a;};d.memset2=function(b,a,c){for(var e=l.U2,d=0;d<c;d=d+1|0)e[b]=a;};d.memset4=function(b,a,c){for(var d=l.U4,f=0;f<c;f=f+1|0)d[b]=a;};d.malloc=function(b){var a=l.U4,c=0,e=0,h=((((b+8|0)-1|0)/8|0)+1|0)>>>0;m(!0);0===(e=n)&&(a[r]=n=e=r,a[r+1]=0);for(c=a[e];;e=c,c=a[c]){if(a[c+1]>=h)return a[c+
1]===h?a[e]=a[c]:(a[c+1]=(a[c+1]-h|0)>>>0,c+=2*a[c+1],a[c+1]=h),n=e,p&&(f.setAddressable(c+2<<2,b,!0),f.setAlloc(c+2<<2,!0)),m(!1),c+2<<2;if(c===n){c=h;e=l.U4;1024>c&&(c=1024);var k;k=d.U4;var g=(8*c|0)/4|0;if(66584576<k[0]+g)k=0;else{var q=k[0];k[0]+=g;k=q;}0===k?c=0:(e[k+1]=c,p&&(f.setAlloc(k+2<<2,!0),f.setAddressable(k+2<<2,c,!0)),v(k+2<<2),m(!0),c=n);if(0===c)return m(!1),0;}}};d.free=v;d.set_memcheck=function(b){p=b;t();};d.memcheck=f;d.memcheck_call_pop=f.memcheck_call_pop;d.memcheck_call_push=
f.memcheck_call_push;d.memcheck_call_reset=f.memcheck_call_reset;}).call(this,'undefined'===typeof exports?memory={}:exports);
}).call(this,require('_process'))
},{"./memcheck.js":3,"_process":1}],3:[function(require,module,exports){
(function (process){
(function(b){function g(a,r,b){for(var c,d=0;d<r;c=d,d=(d+1|0)>>>0,c)f[a+d]|=b}function h(a,b,c){for(var e,d=0;d<b;e=d,d=(d+1|0)>>>0,e)f[a+d]&=~c}function k(){return c.errors.bad_access}function l(){return c.errors.undef_access}function m(){return c.errors.double_free}function n(){return c.used.map(function(a,b){if(a)return{membyte:b,trace:a}}).filter(function(a,b){if(a)return a})}var p=!1;1===("undefined"!==typeof process?1:"undefined"!==typeof snarf?2:3)&&(print=console.log);var c={},q,f,e=[];b.setAddressable=
function(a,b,c){c?g(a,b,1):h(a,b,1)};b.isAddressable=function(a){return f[a]&1?!0:!1};b.setDefined=function(a,b,c){c?g(a,b,2):h(a,b,2)};b.isDefined=function(a){return f[a]&2?!0:!1};b.setAlloc=function(a,b){b?(g(a,1,4),c.used[a]=e.slice(0)):(h(a,1,4),c.used[a]=void 0)};b.isAlloc=function(a){return f[a]&4?!0:!1};b.addDoubleFreeError=function(a){c.errors.double_free.push({membyte:a,trace:e.slice(0)})};b.addBadAccessError=function(a){c.errors.bad_access.push({membyte:a,trace:e.slice(0)})};b.addUndefinedError=
function(a){c.errors.undef_access.push({membyte:a,trace:e.slice(0)})};b.getBadAccesses=k;b.getBadUndefined=l;b.getBadFrees=m;b.getLeaks=n;b.report=function(a){function b(c){return(0<=a?c.slice(0,a):c).map(function(a,b){var c;c=0===a.trace.length?"at <empty stack>":a.trace.reverse().join("\n\tat ");return"address "+a.membyte+"\n\t"+c}).join("\n")}var c="== Memory Leaks ==\n"+b(n()),e="== Access of unallocated memory ==\n"+b(k()),d="== Access of uninitialized memory ==\n"+b(l()),f="== Free of unallocated memory ==\n"+
b(m());return[e,d,f,c].join("\n\n")};b.reset=function(a){q=new ArrayBuffer(a);f=new Uint8Array(q);b.enabled=p=!0;c={used:[],errors:{double_free:[],bad_access:[],undef_access:[]}}};b.enabled=p;b.memcheck_call_pop=function(){e.pop()};b.memcheck_call_push=function(a,b,c,f){e.push(a+" ("+b+".ljs:"+c+":"+f+")")};b.memcheck_call_reset=function(a,b,c){a=e.lastIndexOf(a+":"+b+":"+c);-1!==a&&(e=e.slice(0,a+1))};b.getCallstack=function(){return e}}).call(this,"undefined"===typeof exports?memcheck={}:exports);
}).call(this,require('_process'))
},{"_process":1}]},{},[2])(2)
});